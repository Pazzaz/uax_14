//! An implementation of [UAX #14], also called the `Unicode Line Breaking
//! Algorithm`.
//!
//! [UAX #14]: https://www.unicode.org/reports/tr14/
use std::char;
use std::iter::Peekable;
use std::str::Chars;

/// Convert a `char` to its corresponding [Line Breaking Class].
///
/// *See [`Class`].*
///
/// [Line Breaking Class]: https://www.unicode.org/reports/tr14/#Table1
pub fn convert_to_break_class(n: char) -> Class {
    // Automatically generated by `../build.rs`
    include!(concat!(env!("OUT_DIR"), "/convert_to_break_class"))
}

/// A [Line Breaking Class].
///
/// Interacting directly with Line Breaking Classes is usually not neccessary
/// unless you want to implement something similar to [`LineBreaks`].
///
/// For converting `char` to `Class`, see [`convert_to_break_class`].
///
/// Some classes are missing because of [LB1]. These are [SG] (invalid in any
/// input), [SA] (treated as [CM] or [AL] depending on its General Category),
/// [CJ] (treated as [NS]), [XX], [SG] and [AI] (all treated as [AL]).
///
/// [SG]: https://www.unicode.org/reports/tr14/#SG
/// [SA]: https://www.unicode.org/reports/tr14/#SA
/// [CM]: https://www.unicode.org/reports/tr14/#CM
/// [AL]: https://www.unicode.org/reports/tr14/#AL
/// [CJ]: https://www.unicode.org/reports/tr14/#CJ
/// [NS]: https://www.unicode.org/reports/tr14/#NS
/// [XX]: https://www.unicode.org/reports/tr14/#XX
/// [SG]: https://www.unicode.org/reports/tr14/#SG
/// [AI]: https://www.unicode.org/reports/tr14/#AI
/// [AL]: https://www.unicode.org/reports/tr14/#AL
/// [Line Breaking Class]: https://www.unicode.org/reports/tr14/#Table1
/// [LB1]: https://www.unicode.org/reports/tr14/#LB1
#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Class {
    // Non-tailorable Line Breaking Classes
    BK = 0, // Mandatory Break
    CR = 1, // Carriage Return
    LF = 2, // Line Feed
    CM = 3, // Combining Mark
    NL = 4, // Next Line
    // SG,  // Surrogate - Not used
    WJ = 5,  // Word Joiner
    ZW = 6,  // Zero Width Space
    GL = 7,  // Non-breaking ("Glue")
    SP = 8,  // Space
    ZWJ = 9, // Zero Width Joiner

    // Break Opportunities
    B2 = 10, // Break Opportunity Before and After
    BA = 11, // Break After
    BB = 12, // Break Before
    HY = 13, // Hyphen
    CB = 14, // Contingent Break After

    // Characters Prohibiting Certain Breaks
    CL = 15, // Clone Punctuation
    CP = 16, // Close Parenthesis
    EX = 17, // Exclamation/Interrogation
    IN = 18, // Inseparable
    NS = 19, // Nonstarter
    OP = 20, // Open Punctuation
    QU = 21, // Quatation

    // Numeric Context
    IS = 22, // Infix Numeric Separator
    NU = 23, // Numeric
    PO = 24, // Postfix Numeric
    PR = 25, // Prefix Numeric
    SY = 26, // Symbols Allowing Break After

    // Other Characters
    // AI, // Ambiguous (Alphabetic or Ideographic) - Not used
    AL = 27, // Alphabetic
    // CJ, // Conditional Japanese Starter - Not used
    EB = 28, // Emoji Base
    EM = 29, // Emoji Modifier
    H2 = 30, // Hangul LV Syllable
    H3 = 31, // Hangul LVT Syllable
    HL = 32, // Hebrew Letter
    ID = 33, // Ideographic
    JL = 34, // Hangul L Jamo
    JV = 35, // Hangul V Jamo
    JT = 36, // Hangul T Jamo
    RI = 37, // Regional Indicator
    // SA, // Complex Context Dependent (South East Asian) - Not used
    XX = 38, // Unknown
}

/// Used by [`LineBreaks`] to specify whether a break is allowed or not.
///
/// `Mandatory` is where it is expected to be a line break, `Opportunity` is
/// where it is allowed to be a line break and `Prohibited` is where a line
/// break isn't allowed.
#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Break {
    Mandatory,
    Opportunity,
    Prohibited,
}

include!(concat!(env!("OUT_DIR"), "/states"));

/// An `Iterator` that provides information about possible line breaks in a
/// `str`.
///
/// As it checks the position after every `char`, it will not give
/// information about the position before the very first `char`. Luckily that
/// case is trivial as a line break is never allowed there.
///
/// # Examples
///
/// ```
/// use uax_14::{Break, LineBreaks};
///
/// let input = "Which is tree? æœ¨ç¦¾å¤«ðŸ¤”";
/// let mut split_input = String::new();
/// for (c, br) in LineBreaks::new(&input) {
///     split_input.push(c);
///     if br == Break::Mandatory || br == Break::Opportunity {
///         split_input.push('\n');
///     }
/// }
/// let lines = split_input.split('\n').collect::<Vec<&str>>();
/// assert_eq!(
///     lines,
///     ["Which ", "is ", "tree? ", "æœ¨", "ç¦¾", "å¤«", "ðŸ¤”", ""]
/// );
/// ```
pub struct LineBreaks<'a> {
    iter: Peekable<Chars<'a>>,
    current_state: usize,
}

/// Create a list of all char indices where a line break could be inserted in a
/// `str`.
///
/// This gives back indices that correspond to `char`s in the original input.
/// So 0 is before the first `char`, 1 after the first `char` etc.
pub fn char_line_breaks(input: &str) -> Vec<(usize, Break)> {
    linebreaks(input, true)
}

/// Create a list of all byte indices where a line break could be inserted in a
/// `str`.
///
/// This gives back indices that correspond to bytes in the original input. So
/// 0 is before the first byte, 1 after the first byte etc. This is useful when
/// you want to slice a `str` depending on where line breaks are allowed.
pub fn byte_line_breaks(input: &str) -> Vec<(usize, Break)> {
    linebreaks(input, false)
}

fn linebreaks(input: &str, char_indices: bool) -> Vec<(usize, Break)> {
    let mut current_state = NUM_OF_CLASSES;
    let mut len = 0;
    let mut full: Vec<(usize, Break)> = input
        .char_indices()
        .map(|(byte_index, ch)| (byte_index, convert_to_break_class(ch)))
        .enumerate()
        .filter_map(|(char_index, (byte_index, class))| {
            let (new_state, break_variant) = STATES[current_state][class as usize];
            current_state = new_state;
            len += 1;
            if break_variant == Break::Prohibited {
                None
            } else {
                if char_indices {
                    Some((char_index, break_variant))
                } else {
                    Some((byte_index, break_variant))
                }
            }
        })
        .collect();
    full.push((len, Break::Opportunity));
    full
}

impl<'a> LineBreaks<'a> {
    /// Construct a `LineBreaks` from a `&str`.
    #[inline]
    pub fn new(input: &'a str) -> LineBreaks<'a> {
        let mut i = input.chars().peekable();
        let mut out = LineBreaks {
            iter: i.clone(),
            current_state: NUM_OF_CLASSES,
        };
        out.possible_break(convert_to_break_class(*i.peek().unwrap()));
        out
    }

    fn possible_break(&mut self, c: Class) -> Break {
        let (new_state, br) = STATES[self.current_state][c as usize];
        self.current_state = new_state;
        br
    }
}

/// Provide information as to whether a line break can be appended for each
/// `char` in the input.
impl<'a> Iterator for LineBreaks<'a> {
    type Item = (char, Break);
    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        let tuple = match (self.iter.next(), self.iter.peek()) {
            (Some(a), Some(&b)) => {
                (
                a,
                self.possible_break(convert_to_break_class(b)),
            )
            },
            (None, Some(_)) => unreachable!(),
            (Some(a), None) => (a, Break::Opportunity),
            (None, None) => {
                return None;
            }
        };
        Some(tuple)
    }
}
